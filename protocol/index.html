<html>
  <head>
    <title>Keybase Secure Threaded Messaging (KSTM)</title>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: { inlineMath: [['$','$'],['\\(','\\)']] }
      });
    </script>
    <style>
    body {
      max-width:600px;
      margin-left:100px;
      margin-right:100px;
      font-family: times;
    }
    p {
      margin-bottom:20px;
    }
    ol {
      font-size:1.0em;
    }
    li {
      margin-top:10px;
    }
    h1,h2 {
      margin-top:30px;
    }
    h3 {
      margin-top:20px;
    }
    ol,ul {
      margin-top: 10px;
      margin-bottom: 20px;
    }
    .authorblock {
      margin-left: 50px; 
    }
    </style>
  </head>
  <body>

    <h1>Keybase Secure Threaded Messaging (KSTM)</h1>

    <div class="authorblock">
      By: Maxwell Krohn (max AT keybase.io)<br/>
      Version: 1.0.1<br/>
      Last update: 2014-05-06<br/>
    </div>

    <h2>Application Goals</h2>

    <p>
      The goal is to build a protocol and system for secure messaging between
      2 or more conversants.  Those in the conversation will see a "threaded",
      persistent view, much like Facebook email.  Conversants can jump between several
      clients and machines, and are assumed to have spotty network connectivity.
    </p>

    <h2>Assumptions</h2>

    <ul>
      <li><strong>TLS Transport Layer with Perfect Forward-Secrecy</strong>.
        Communication to and from that server is protected with TLS, and preferably
        with DHE or ECDHE key-exchanges for foward-secrecy.
      </li>

      <li><strong>Public Key Exchange</strong>.
        Clients can get each other's public PGP keys via Keybase or some other mechanism.
      </li>

    </ul>

    <h2>Security Goals</h2>

    <p>
      Though we would ideally like a protocol with Perfect Forward Secrecy, in practice,
      we can't come up with a useful, convenient, asynchronous PFS protocol that seemlessly
      supports multiple devices and spotty connectivity.  Some protocols 
      achieve <a href="http://eprint.iacr.org/2003/083">Non-Interactive Forward Secrecy</a>,
      with experimental and challenging cryptography. 
      <a href="https://whispersystems.org/blog/asynchronous-security/">Others</a> propose a 
      Diffe-Hellman pre-keying approach, which breaks down if
      adversaries malliciously exhaust pregenerated keys, and futhermore 
      requires $O(m^2n^2)$ network messages per interaction if there are $m$ conversants with $n$ devices each.
    </p>

    <p>
      So don't shoot for perfect forward-secret, but here are the goals we do hope to achieve:

      <ol>
        <li><strong>At least a PGP-level of security</strong>. If all parties keep their keys protected, the conversation is secret 
            and resilient to forgery and impersonation.</li>
        <li><strong>Resilience to server compromise</strong>. if the server is compromised:
          <ul>
            <li>Guarantee #1 is still upheld.</li>
            <li>All thread metadata is still secret; the attacker can't discover who was involved in which conversations.</li>
          </ul>
        </li>
        <li><strong>Authentication</strong>. Users can authenticate themselves and their
          messages to other conversants in the conversation.</li>
        <li><strong>Weak repudiation</strong>. If any conversant in the thread has their private key compromised, and if the
         server is compromised, conversations older than a given timeout can still be repudiated.</li>
        <li><strong>Weak forward secrecy</strong>. If the server is compromised, and if any number of conversants have their
         keys compromised, the adversary still cannot recover <em>deleted</em> messages.</li>  
      </ol>
    </p>

    <h2>High-Level Design</h2>

    <p>
      The message system is decomposed into two systems: (1) an inbox system;
      and (2) a message-threading system.  The inbox system is in charge of
      notifying users when they have new messages, and keeping track of which
      message threads they take part in. A user registers for an inbox server
      just once, and then uses the same inbox server for all future
      conversations.
    </p>

    <p>
      A message-threading server manages the specifics of a message thread,
      which is a series of messages and replies among a fixed set of conversants.
      The user who initiates the conversation picks the message-threading server, 
      but the conversants can be spread across independent inbox servers.
    </p>

    <p>
      Users on the system must globally register the following two properties:
      <ul>
        <li>A public key</li>
        <li>An inbox server, signed with the user's public key, potentially stored as
            a <a href="https://tools.ietf.org/html/rfc4880#section-5.12">user-attribute</a>
            in the user's public key.</li>
      </ul>
      At first, the Keybase server will implement all parts of the system, but
      users have the option to switch to different platforms and
      implementations as they choose.
    </p>



    <h2>Message Threading Design</h2>

    <p>
      Assume that Alice wants to start a conversation with Bob and Charlie.  She first picks
      a threading server that she has some amount of faith in.  That could be the one Keybase.io provides,
      or one she maintains, etc.  Alice, Bob and Charlie will all have to communicate with the
      same server for the purposes of this conversation.
    </p>


    <h3>Step 1: Initializing the Thread, Client Side</h3>

    <p> 
      Alice initializes the conversation. She:

      <ol>
        <li>Generates two random session keys:
          <ul>
            <li>$k_s$, a 256-bit AES key</li>
            <li>$k_m$, a 256-bit key used to maintain message integrity; it will be used as key to HMAC-SHA512.</li>
          </ul>
        </li>
        <li>For each conversant, generates a random "write-token", the possesion of which will allow Alice, Bob
            and Charlie to post to the server as themselves.  Call these tokens $t_A$, $t_B$, and $t_C$.
            They are random 128-bit strings.</li>
        <li>Generates a thread ID: $i$</li>
        <li>Looks up public keys $K_A, K_B$ and $K_C$ via whatever key distribution mechanism she prefers.</li>
        <li>Creates a "thread init message" for each of the three conversants:
          <ul>
            <li>$e_A = E_{K_A}([ i, t_A, [A,B,C], k_s, k_m ])$</li>
            <li>$e_B = E_{K_B}([ i, t_B, [A,B,C], k_s, k_m ])$</li>
            <li>$e_C = E_{K_C}([ i, t_C, [A,B,C], k_s, k_m ])$</li>
          </ul>
          Note that Alice can use PGP messages for this, but she ought to strip out the exterior part of the 
          message that identifies which public key the message is intended for.  She should overwrite this part 
          of the message with <code>0</code> bytes.  She also should not sign the message.
        </li>
        <li>
          Sends an initialization message to the server: $[\textrm{init}, i, [t_A, e_A], [t_B, e_B], [t_C, e_C] ]$
        </li>
      </ol>
    </p>

    <h3>Step 2: Initializing the Thread, Server side</h3>

    <p>
      The server receives the message Alice sent in the previous Step.  The server writes this information to its database
      and reserve slots for users $U_0, U_1$ and $U_2$ in conversation $i$.  Note that $U_0, U_1$ and $U_2$ are
      the server's pseudoynms for $A$, $B$ and $C$ on the clients. The server doesn't know the identities of Alice, Bob 
      or Charlie, so it can't refer to them as $A$, $B$, or $C$.
    </p>
    <p>
      By convention, the clients should always order user IDs from least to highest UID, to that way the correspondence
      of $A$ to $U_0$, $B$ to $U_1$ etc, is agreed upon by all conversants and the server.
    </p>

    <h3>Step 3: Notification</h3>

    <p>
      Alice now needs to notify Bob and Charlie that they should check for messages on the server.
      She really only needs to send them $i$ and the server name, and can do so in the clear or protected with crypto.
    </p>
    <p>
      Alice looks up the inbox servers that Bob and Charlie registered. As stated above, they can
      specify such a server in the User-attribute packet of their keys. For the case of Bob, Alice
      sends a message $[\textrm{notify}, B, E_{K_B}([u, 0]) ]$ to Bob's registered
      inbox server. The parameters are:

      <ul>
        <li>$B$, Bob's user ID</li>
        <li>$u$, the URL of this thread, which takes the form:
         <blockquote>
           <code>https://<em>N</em>/<em>i</em></code>
         </blockquote>
         where $N$ is the name of this thread-server, and $i$ is the ID of the conversation.
         $N$ can be a standard domain name, or a Tor-routed domain name, for instance. 
         Protocols other than <code>https</code> might eventually be supported.</li>
        <li>$0$, the message ID of the message in the thread, which is $0$ since the thread is just starting up.</li>
      </ul>

    </p>

    <h3>Step 3: Key Establishment</h3>

    <p>
      Bob, Charlie (and Alice if she switched machines) query the server for
      $[\textrm{key-lookup}, i, j]$, where $j$ is their position in the
      relative order of user IDs. The server replies with the $j$th encrypted
      message in conversation $i$ that Alice sent in Step 1.  They can now
      decrypt and recover $k_s, k_m$.
    </p>

    <h3>Step 3b: Token Swap</h3>

    <p>
      Charlie can ask the server to swap his existing token $t_B$ for a new token $t'_B$, one that Alice doesn't know.
      He probably should do this before authenticating himself in Step 4.
    </p>

    <h3>Interlude: Channel Encryption</h3>

    <p>
      Now Alice, Bob and Charlie are ready to communicate over the channel they've established.
      The do this with AES256-encryption in CTR mode, and authenticated with HMAC-SHA512.
      Given keys $k_s$ and $k_m$ and plaintext $p$, define $E_{k_s,k_m}(p)$ as:
      <ul>
        <li>Pick a random nonce $r$</li>
        <li>Generate ciphertext: $c = \mathrm{AES256CTR}_{k_s}(r,p)$</li>
        <li>Generate MAC: $m = \mathrm{SHA512HMAC}_{k_m}(r,c)$</li>
        <li>Output encryption: $[r,c,m]$</li>
      </ul>
    </p>

    <h3>Step 4: Authentication</h3>

    <p>
      Any user in the conversation can optionally prove their identity and authenticate their messages in the
      conversation.  Without this guarantee, Alice, Bob and Charlie can still converse, but they have no guarantee
      that they are conversing with authentic people.
    </p>

    <p>
      Authentication is the same for all conversants, but take Bob for example:
      <ol>
        <li>Bob generates a temporary keypair: $k'_{B}, K'_{B}$</li>
        <li>Bob generates a signature $s = \sigma_{k_{B}}([i, K'_{B}])$</li>
        <li>Bob encrypts $e = E_{k_s,k_m}([K'_{B}, s])$.</li>
        <li>Bob sends $[\textrm{auth}, i, t_B, e]$ to the server</li>
        <li>The server will only allow this signature to be posted if $t_B$ matches the "write token" that Alice
            established for Bob in Step 1, or a new one he established in Step 3b.</li>
        <li>Bob can also send $[\textrm{store-key}, i, t_B, E_{B}(k'_{B})]$ to the server.
            That is, he can store his temporary signing key, protected with his long-lived secret key,
            to the server so he can later retrieve it if he switches clients during the thread.</li>
      </ol>
    </p>

    <p>
      Once Bob has posted this message to the server, all conversants can retrieve it, and verify Bob's signature.
      Once they do, they have Bob's temporary public key $K'_{B}$.
    </p>

    <h3>Step 5: Sending Messages</h3>

    <p>
      When Bob wants to send a message $m$ to the group, he computes

      \[e = E_{k_s,k_m}([m, \sigma_{k'_{B}}([i, m])]) \]

      That is, he signs the message he wants to post with his temporary signing key, then encrypts using
      the session key for this conversation. Bob can alternatively send an unauthenticated message to the group,
      but Alice and Charlie's clients will show the message as unauthenticated. 
    </p>

    <p>
      Bob posts this message to the server as $[\textrm{post}, i, t_B, e]$
    </p>

    <p>
      The server serializes these messages. Optionally, the clients can sign the sequence number of the last received
      message when sending new messages.  All users in the conversation can request all messages from thread $i$ at any
      time, though Bob should send a notifiction (see above) to Alice and Charlie when posting a new message to the thread.
    </p>

    <h3>Step 6: Deleting Messages and Keys</h3>

    <p>
      The server maintains a deletion pointer $k$ for each user $j$ in conversation $i$.  Charlie can bump his
      deletion pointer for thread $i$ to $k$ if he sends a message $[\textrm{delete-msg}, i, t_C, k]$ to the server. Once
      has been bumped past $k$ by all conversants, the server can delete messages through $k$ in the thread.
    </p>

    <p>
      Charlie also can ask the server to delete his session keys, via $[\textrm{delete-key}, i, t_C]$.
      After this point, Alice and Bob need to take the server's word that messages coming from Charlie
      are indeed from Charlie.  Charlie can also, later on, post a new session key if he pleases.
    </p>

    <h2>Inbox Design</h2>

    <p>
      The Inbox server maintains a persistent mapping from a user to a set of active threads, 
      and notifies users of new activities on any of their threads.  As stated earlier, it gets
      messages of the form:
       \[ 
        [ \textrm{notify}, B, E_{K_B}([u, k]) ]
       \]
      Where $B$ is the ID of the user receiving a notification, $u$ is the URL to access
      the thread, and $k$ is the most recent serial message ID in the thread.
    </p>

    <p>
      When the inbox server gets such a message for user $B$, it sends some sort of SMS, push,
      or plaintext email to Bob that he has new mail waiting for him. The decision is left to the
      inbox server provider.  However, the provider should not send any
      unencrypted metadata in the push notification, for fear that some passive eavesdropper can 
      intercept it.
    </p>

    <p>
      Inbox servers should also provide an interface to retrieval, management
      and compaction of inboxes.  Here are some anticipated RPCs the inbox server
      should service:

      <ul>
        <li>
          <strong>inbox</strong>: get inbox threads for the given user. If no query parameters
          is provided, then get all messages; otherwise, the server can sort them and access
          them by time.
        </li>
        <li>
          <strong>delete</strong>: delete the given inbox threads.
        </li>
        <li>
          <strong>compact</strong>: replace one set of inbox threads with another. This 
          endpoint allows Bob to optimize future inbox accesses, by combining several
          encrypted messages into single messages, that can be decrypted in one shot rather
          than $n$.
        </li>
      </ul>
    </p>

 </body>
</html>
